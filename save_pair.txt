#ifndef PAIR_HPP
# define PAIR_HPP

namespace ft
{
	template <typename T1, typename T2>
	struct pair // a pair of objects
	{
		typedef T1 first_type; typedef T2 second_type; T1 first; T2 second;

		pair() : first(), second() {}
		~pair() {}
		pair(const T1 & first, const T2 & second) : first(first), second(second) {}
		pair(const pair &other) : first(other.first), second(other.second) {}
		// this ctor works with iterator types
		template <typename A, typename B>
		pair(const pair<A, B> & ptr) : first(ptr.first), second(ptr.second) {}
		pair & operator=(const pair & other) {
			if (*this == other) { return (*this); }
			first = other.first; second = other.second;  return (*this);
		}
	}; // struct pair

	template <typename T1, typename T2>
	pair<T1, T2> make_pair(const T1 t1, const T2 t2)
		{ return (pair<T1, T2>(t1, t2)); }

	template <typename T1, typename T2>
	bool operator==(const ft::pair<T1, T2> & lhs, const ft::pair<T1, T2> & rhs)
		{ return (lhs.first == rhs.first && lhs.second == rhs.second); }

}; //namespace ft

#endif // PAIR_HPP
